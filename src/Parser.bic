import "vector";
import "Token.bic";
import "Lexer.bic";
import "AST.bic";

class ParserState {
    pub mut state : std::string;
    pub mut token : Token*;
    pub mut current : int;

    pub ParserState(state : std::string, current : int) {
        .state = state;
        .current = current;
    }
}

enum BodyType {
    Decl,
    Impl
}

class Parser {
    mut lexer : Lexer*;
    mut tokens : std::vector<Token>;
    mut current : int;
    mut currentToken : Token*;
    mut stateStack : std::vector<ParserState>;
    mut state : std::string;

    pub Parser(lexer : Lexer*) {
        .lexer = lexer;
        .tokens = lexer->Parse();
        .current = 0;
        .currentToken = &.tokens[.current];
    }

    pub Parse() -> ASTNode* {
        ret .Program();
    }

    PushState(state : std::string) -> void {
        .state = state;
        .stateStack.push_back(ParserState(.state, .current));
    }

    PopState(drop : bool) -> void {
        if ((.stateStack.size()) > 0) {
            .state = (.stateStack.back()).state;

            if (!drop) {
                .current = (.stateStack.back()).current;
                .currentToken = &.tokens[.current];
            }
        }

        .stateStack.pop_back();
    }

    ShowState() -> void {
        std::cout << "State: ";

        mut i : int = 0;
        while ((i) < .stateStack.size()) {
            std::cout << (.stateStack[i]).state << " <- ";
            i++;
        }
        std::cout << "\n";
    }

    IsInsideState(state : std::string) -> bool {
        mut i : int = 0;
        while ((i) < .stateStack.size()) {
            if ((.stateStack[i]).state == state) {
                ret true;
            }
            i++;
        }
        ret false;
    }

    Eat(tokenType : TokenType) -> void {
        if ((.currentToken->tokenType) == tokenType) {
            .current += 1;
            .currentToken = &.tokens[.current];
        }
        else {
            .Error("Expected " + TokenTypeToString(tokenType) + ", got " + TokenTypeToString(.currentToken->tokenType));
        }
    }

    Backtrack() -> void {
        if (.current > 0) {
            .current -= 1;
            .currentToken = &.tokens[.current];
        }
    }

    Error(msg : std::string) -> void {
        std::cout << "Error: " << msg << std::endl;
        exit(0);
    }

    IsAtEnd() -> bool {
        ret (.currentToken->tokenType) == (TokenType::EndOfFile);
    }

    IsType(tokenType : TokenType) -> bool {
        ret (.currentToken->tokenType) == tokenType;
    }

    IsKeyword() -> bool {
        ret (.currentToken->tokenType) > (TokenType::StartKeyword) && (.currentToken->tokenType) < (TokenType::EndKeyword);
    }

    IsState(state : std::string) -> bool {
        ret .state == state;
    }

    // Program -> Decl*
    Program() -> ASTNode* {
        mut decls : std::vector<ASTNode*>;

        while (!.IsAtEnd()) {
            decls.push_back(.DeclStatement());
        }

        ret new ASTProgram(decls);
    }

    // Expr: Term 
    Expr() -> ASTExpr* {
        ret new ASTExpr(.AssignExpr());
    }

    // AssignExpr: CompExpr (("=" | "+=" | "-=" | "*=" | "/=" | "%=") CompExpr)*
    AssignExpr() -> ASTNode* {
        mut node : ASTNode* = .CompExpr();

        while ((.IsType(TokenType::Assign)) || 
               (.IsType(TokenType::AddAssign)) || 
               (.IsType(TokenType::SubAssign)) || 
               (.IsType(TokenType::MulAssign)) ||
               (.IsType(TokenType::DivAssign)) ||  
               (.IsType(TokenType::ModAssign))) {
            let op : Token* = .currentToken;
            .Eat(.currentToken->tokenType);
            let right : ASTNode* = .CompExpr();
            node = new ASTBinaryOp(node, *op, right);
        }

        ret node;
    }

    // CompExpr: Term ("==" | "!=" | "<" | "<=" | ">" | ">=") Expr
    CompExpr() -> ASTNode* {
        mut node : ASTNode* = .ShiftExpr();

        if ((.IsType(TokenType::Equal)) ||
            (.IsType(TokenType::NotEqual)) || 
            (.IsType(TokenType::Less)) || 
            (.IsType(TokenType::LessEqual)) ||
            (.IsType(TokenType::Greater)) || 
            (.IsType(TokenType::GreaterEqual))) {
            
            if ((.IsInsideState("TemplateArgs")) && (.IsType(TokenType::Greater))) {
                ret node;
            }

            let op : Token* = .currentToken;
            .Eat(op->tokenType);

            let right : ASTNode* = .Expr();
            node = new ASTBinaryOp(node, *op, right);
        }

        ret node;
    }

    // ShiftExpr: Term ("<<" | ">>") Expr
    ShiftExpr() -> ASTNode* {
        mut node : ASTNode* = .Term();

        if ((.IsType(TokenType::LShift)) || 
            (.IsType(TokenType::RShift))) {
            let op : Token* = .currentToken;
            .Eat(op->tokenType);

            let right : ASTNode* = .Expr();
            node = new ASTBinaryOp(node, *op, right);
        }

        ret node;
    }

    // Term: Factor ('+' | '-') Expr 
    Term() -> ASTNode* {
        mut node : ASTNode* = .BitwiseExpr();

        if ((.IsType(TokenType::Add)) || (.IsType(TokenType::Sub))) {
            let token : Token* = .currentToken;
            .Eat(token->tokenType);
            
            let right : ASTNode* = .Expr();
            node = new ASTBinaryOp(node, *token, right);
        }

        ret node;
    }

    // BitwiseExpr: Term ('|' | '&' | '^') BitwiseExpr
    BitwiseExpr() -> ASTNode* {
        mut node : ASTNode* = .Factor();

        if ((.IsType(TokenType::And))) {
            let token : Token* = .currentToken;
            .Eat(token->tokenType);
            
            .PushState("CheckingForPointer");
            let right : ASTNode* = .Expr();
            
            if (right != null) {
                .PopState(true);
                node = new ASTBinaryOp(node, *token, right);
            }
            else {
                .PopState(false);
                node = new ASTReferenceDecl(node);
            }
        }
        elif ((.IsType(TokenType::Or)) ||  
              (.IsType(TokenType::Xor))) {
            let token : Token* = .currentToken;
            .Eat(token->tokenType);
            
            let right : ASTNode* = .Expr();
            node = new ASTBinaryOp(node, *token, right);
        }

        ret node;
    }

    // Factor: Unary ('*' | '/' | '%') Factor
    Factor() -> ASTNode* {
        mut node : ASTNode* = .Unary();
        
        if (.IsType(TokenType::Mul)) {
            let token : Token* = .currentToken;
            .Eat(token->tokenType);
            
            .PushState("CheckingForPointer");
            let right : ASTNode* = .Factor();
            
            if (right != null) {
                .PopState(true);
                node = new ASTBinaryOp(node, *token, right);
            }
            else {
                .PopState(false);
                node = new ASTPointerDecl(node);
            }
        }
        elif ((.IsType(TokenType::Div)) || (.IsType(TokenType::Mod))) {
            let token : Token* = .currentToken;
            .Eat(token->tokenType);
            let right : ASTNode* = .Factor();
            node = new ASTBinaryOp(node, *token, right);
        }

        ret node;
    }

    // Unary: ('+' | '-' | '!' | '~' ) Unary | FunctionCall
    Unary() -> ASTNode* {
        if ((.IsType(TokenType::Add)) ||
            (.IsType(TokenType::Sub)) || 
            (.IsType(TokenType::Not)) || 
            (.IsType(TokenType::BitNot))) {
            let token : Token* = .currentToken;
            .Eat(token->tokenType);
            
            let right : ASTNode* = .Unary();

            ret new ASTUnaryOp(*token, right);
        }
        elif ((.IsType(TokenType::And)) || (.IsType(TokenType::Mul))) {
            let token : Token* = .currentToken;
            .Eat(token->tokenType);
            
            let right : ASTNode* = .Unary();
            ret new ASTUnaryOp(*token, right);
        }
        
        ret .DotAccess();
    }

    // FunctionCall: DotAccess ('(' ArgsValue? ')') | DotAccess
    FunctionCall() -> ASTNode* {
        mut node : ASTNode* = .IndexAccess(.Primary());

        if (node == null) { ret null; }

        if (.IsType(TokenType::LParen)) {
            .Eat(TokenType::LParen);
            if (.IsType(TokenType::RParen)) {
                .Eat(TokenType::RParen);
                ret new ASTFunctionCall(node);
            }

            let args : std::vector<ASTNode*> = .ArgsValue();
            .Eat(TokenType::RParen);
            ret new ASTFunctionCall(node, args);
        }

        ret node;
    }

    // DotAccess: IndexAccess ('.' | '->') DotAccess
    DotAccess() -> ASTNode* {
        mut node : ASTNode* = .IndexAccess(.FunctionCall());
        if (node == null) { ret null; }

        if ((.IsType(TokenType::Dot)) || (.IsType(TokenType::Arrow))) {
            let token : Token* = .currentToken;
            .Eat(token->tokenType);
            
            node = new ASTDotAccess(node, *token,  .DotAccess());
        }

        ret node;
    }

    // IndexAccess: Primary ('[' Expr ']')*
    IndexAccess(node : ASTNode*) -> ASTNode* {
        if (node == null) { ret null; }

        while (.IsType(TokenType::LBracket)) {
            let token : Token* = .currentToken;
            .Eat(token->tokenType);

            let index : ASTNode* = .Expr();
            .Eat(TokenType::RBracket);
            
            node = new ASTIndexOp(node, index);
        }

        ret node;
    }

    // Primary: Int | Float | '(' Expr ')' | Variable
    Primary() -> ASTNode* {
        mut node : ASTNode*;

        if (.IsType(TokenType::Int)) {
            node = new ASTConstant(.currentToken->literal);
            .Eat(TokenType::Int);
        }
        elif (.IsType(TokenType::Float)) {
            node = new ASTConstant(.currentToken->literal);
            .Eat(TokenType::Float);
        }
        elif (.IsType(TokenType::True)) {
            node = new ASTConstant(.currentToken->literal);
            .Eat(TokenType::True);
        }
        elif (.IsType(TokenType::Null)) {
            node = new ASTConstant(.currentToken->literal);
            .Eat(TokenType::Null);
        }
        elif (.IsType(TokenType::False)) {
            node = new ASTConstant(.currentToken->literal);
            .Eat(TokenType::False);
        }
        elif (.IsType(TokenType::LParen)) {
            .Eat(TokenType::LParen);
            node = .Expr();
            .Eat(TokenType::RParen);
        } 
        elif (.IsType(TokenType::Ident)) {
            node = .ScopeResolution();
        }
        elif (.IsType(TokenType::String)) {
            node = new ASTConstant(.currentToken->literal);
            .Eat(TokenType::String);
        }
        else {
            if (.IsInsideState("CheckingForPointer")) {
                ret null;
            }
            .Error("Expected an expression");
        }

        ret node;
    }

    // IdentDecl: Identifier ('[' Expr ']')*
    IdentDecl() -> ASTNode* {
        mut node : ASTNode* = new ASTVariable(.currentToken->literal);
        .Eat(TokenType::Ident);

        while (.IsType(TokenType::LBracket)) {
            .Eat(TokenType::LBracket);
            let index : ASTNode* = .Expr();
            .Eat(TokenType::RBracket);
            
            node = new ASTIndexOp(node, index);
        }

        ret node;
    }

    // Variable: Identifier ('<' TemplateArgs '>')?
    Variable() -> ASTNode* {
        mut node : ASTNode*;

        if (.IsType(TokenType::Ident)) {
            node = new ASTVariable(.currentToken->literal);
            .Eat(TokenType::Ident);
        }
        elif (.IsType(TokenType::Class)) {
            node = new ASTVariable(.currentToken->literal);
            .Eat(TokenType::Class);
        }
        elif (.IsType(TokenType::Type)) {
            node = new ASTVariable(.currentToken->literal);
            .Eat(TokenType::Type);
        }
        else {
            .Error("Expected an identifier");
        }

        if (.IsType(TokenType::Less)) {
            let tmp : ASTTemplateArgs* = .TemplateArgs(node);

            if (tmp != null) {
                node = tmp;
            }
        }

        ret node;
    }

    // ScopeResolution: Variable ('<' TemplateArgs '>')? ('::' Variable ('<' TemplateArgs '>')?)*
    ScopeResolution() -> ASTNode* {
        mut node : ASTNode* = .Variable();

        if (.IsType(TokenType::Less)) {
            let tmp : ASTTemplateArgs* = .TemplateArgs(node);

            if (tmp != null) {
                node = tmp;
            }
        }

        while (.IsType(TokenType::ScopeResolution)) {
            .Eat(TokenType::ScopeResolution);
            mut right : ASTNode* = .Variable();

            if (.IsType(TokenType::Less)) {
                let tmp : ASTTemplateArgs* = .TemplateArgs(right);

                if (tmp != null) {
                    right = tmp;
                }
            }

            node = new ASTScopeResolution(node, right);
        }
        

        ret node;
    }

    // TemplateArgs: node '<' ArgsValue '>'
    TemplateArgs(node : ASTNode*) -> ASTTemplateArgs* {
        .PushState("TemplateArgs");
        .Eat(TokenType::Less);
        let args : std::vector<ASTNode*> = .ArgsValue();
        
        if (.IsType(TokenType::Greater)) {
            .Eat(TokenType::Greater);
            .PopState(true);
            ret new ASTTemplateArgs(node, args);
        }
        .PopState(false);
        
        mut i : int = 0;
        while ((i) < args.size()) {
            del args[i];
            i += 1;
        }

        ret null;
    }

    // ArgsValue: Expr (',' Expr)*
    ArgsValue() -> std::vector<ASTNode*> {
        mut args : std::vector<ASTNode*>;

        args.push_back(.Expr());

        while (.IsType(TokenType::Comma)) {
            .Eat(TokenType::Comma);
            args.push_back(.Expr());
        }

        ret args;
    }

    // End of expresion parsing
    // Start of statement parsing

    // Body: '{' (Statement)* '}'
    Body(bodyType : BodyType) -> ASTBody* {
        .Eat(TokenType::LBrace);
        mut body : ASTBody* = new ASTBody();
        mut stmt : ASTNode*;

        while (!(.IsType(TokenType::RBrace))) {
            if (bodyType == BodyType::Decl) {
                stmt = .DeclStatement();
            }
            else {
                stmt = .ImplStatement();
            }
            body->AddStatement(stmt);
            
            if (.IsType(TokenType::EndOfFile)) {
                break;
            }
        }

        .Eat(TokenType::RBrace);
        ret body;
    }

    // Type: ScopeResolution ('*')* ('&')?
    Type() -> ASTType* {
        mut isConst : bool = false;
        if (.IsType(TokenType::Const)) {
            .Eat(TokenType::Const);
            isConst = true;
        }

        mut left : ASTNode* = .ScopeResolution();

        while (.IsType(TokenType::Mul)) {
            .Eat(TokenType::Mul);
            left = new ASTPointerDecl(left);
        }

        if (.IsType(TokenType::And)) {
            .Eat(TokenType::And);
            left = new ASTReferenceDecl(left);
        }

        mut ntype : ASTType* = new ASTType(left);
        ntype->isConst = isConst;

        ret ntype;
    }

    // ArgDecl: IdentDecl : Type
    ArgDecl() -> ASTArgDecl* {
        let name : ASTNode* = .IdentDecl();
        .Eat(TokenType::Colon);
        let _type : ASTNode* = .Type();

        ret new ASTArgDecl(name, _type);
    }

    // TypedArgs: ArgDecl (',' ArgDecl)*
    TypedArgs() -> std::vector<ASTArgDecl*> {
        mut args : std::vector<ASTArgDecl*>;

        args.push_back(.ArgDecl());

        while (.IsType(TokenType::Comma)) {
            .Eat(TokenType::Comma);
            args.push_back(.ArgDecl());
        }

        ret args;
    }

    // TemplateDecl: '<' TypedArgs '>' 
    TemplateDecl() -> ASTTemplateDecl* {
        .PushState("TemplateDecl");
        .Eat(TokenType::Less);
        let args : std::vector<ASTArgDecl*> = .TypedArgs();
        
        if (.IsType(TokenType::Greater)) {
            .Eat(TokenType::Greater);
            .PopState(true);
            ret new ASTTemplateDecl(args);
        }
        .PopState(false);
        
        mut i : int = 0;
        while ((i) < args.size()) {
            del args[i];
            i += 1;
        }

        ret null;
    }

    // VariableDecl: ('mut' | 'let') IdentDecl ':' Type ('=' Expr)?
    VariableDecl() -> ASTVariableDecl* {
        mut isMutable : bool = false;

        if (.IsType(TokenType::Mut)) {
            isMutable = true;
            .Eat(TokenType::Mut);
        }
        else {
            .Eat(TokenType::Let);
        }

        let name : ASTNode* = .IdentDecl();

        .Eat(TokenType::Colon);
        let _type : ASTType* = .Type();

        mut expr : ASTExpr* = null;
        if (.IsType(TokenType::Assign)) {
            .Eat(TokenType::Assign);
            expr = .Expr();
        }

        ret new ASTVariableDecl(name, _type, expr, isMutable);
    }

    // FunctionDecl: Identifier TemplateDecl? '(' TypedArgs ')' ('->' Type)? Body
    FunctionDecl() -> ASTFunctionDecl* {
        let name : ASTVariable* = new ASTVariable(.currentToken->literal);
        .Eat(TokenType::Ident);

        mut tmp : ASTTemplateDecl* = null;
        if (.IsType(TokenType::Less)) {
            tmp = .TemplateDecl();
        }

        .Eat(TokenType::LParen);
        mut args : std::vector<ASTArgDecl*>;
        if (.IsType(TokenType::RParen)) {
            .Eat(TokenType::RParen);
        }
        else {
            args = .TypedArgs();
            .Eat(TokenType::RParen);
        }

        mut attrs : int = false;
        if (.IsType(TokenType::Const)) {
            .Eat(TokenType::Const);
            attrs |= Attribute::Const;
        }

        .Eat(TokenType::Arrow);
        let _type : ASTType* = .Type();
        let body : ASTBody* = .Body(BodyType::Impl);

        mut func : ASTFunctionDecl* = new ASTFunctionDecl(name, tmp, args, _type, body);
        func->attr = attrs;
        
        ret func;
    }

    // ReturnStmt: 'ret' Expr
    ReturnStmt() -> ASTReturn* {
        .Eat(TokenType::Ret);
        ret new ASTReturn(.Expr());
    }

    // IfStmt: 'if' Expr Body ('elif' Body)* ('else' Body)?
    IfStmt() -> ASTIf* {
        .Eat(TokenType::If);
        let cond : ASTExpr* = .Expr();
        let body : ASTBody* = .Body(BodyType::Impl);

        mut elifs : std::vector<ASTIf*>;

        while (.IsType(TokenType::Elif)) {
            .Eat(TokenType::Elif);
            let elifCond : ASTExpr* = .Expr();
            let elifBody : ASTBody* = .Body(BodyType::Impl);
            elifs.push_back(new ASTIf(elifCond, elifBody));
        }

        mut elseBody : ASTBody* = null;
        if (.IsType(TokenType::Else)) {
            .Eat(TokenType::Else);
            elseBody = .Body(BodyType::Impl);
        }

        ret new ASTIf(cond, body, elifs, elseBody);
    }
    
    // DeclStatement:
    //     VariableDecl
    //     | FunctionDecl
    DeclStatement() -> ASTNode* {
        if (.IsType(TokenType::Semicolon)) {
            .Eat(TokenType::Semicolon);
            ret null;
        }
        elif ((.IsType(TokenType::Let)) || (.IsType(TokenType::Mut))) {
            let node : ASTNode* = .VariableDecl();
            .Eat(TokenType::Semicolon);
            ret node;
        }
        elif (.IsType(TokenType::Ident)) {
            ret .FunctionDecl();
        }

        ret null;
    }
    
    // ImplStatement:
    //      VariableDecl
    //      | ReturnStmt
    //      | IfStmt
    //      | Expr
    ImplStatement() -> ASTNode* {
        mut node : ASTNode* = null;

        if (.IsType(TokenType::Semicolon)) {
            .Eat(TokenType::Semicolon);
            ret null;
        }
        elif ((.IsType(TokenType::Let)) || (.IsType(TokenType::Mut))) {
            node = .VariableDecl();
            .Eat(TokenType::Semicolon);
        }
        elif (.IsType(TokenType::Ret)) {
            node = .ReturnStmt();
            .Eat(TokenType::Semicolon);
        }
        elif (.IsType(TokenType::If)) {
            node = .IfStmt();
        }
        else {
            node = .Expr();
            .Eat(TokenType::Semicolon);
        }
        
        ret node;
    }

}