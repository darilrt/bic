include "iostream";
include "vector";
include "string";
include "Token.cic";

class Lexer {
    pub mut source : std::string;
    mut index : int;
    mut column : int;
    mut line : int;
    mut tokens : std::vector<Token>;
    mut currentChar : char;

    pub Lexer(source : const std::string&) {
        .source = source;
        .index = 0;
        .column = 1;
        .line = 1;
        .currentChar = .source[.index];
    }

    Peek() -> char {
        if .index + 1 < .source.size() {
            ret .source[.index + 1];
        }
        ret '\0';
    }

    Peek2() -> char {
        if .index + 2 < .source.size() {
            ret .source[.index + 2];
        }
        ret '\0';
    }

    PeekEquals(expected : char) -> bool {
        let peek : char = .Peek();
        if peek == expected {
            ret true;
        }
        ret false;
    }

    Peek2Equals(expected : char) -> bool {
        let peek : char = .Peek2();
        if peek == expected {
            ret true;
        }
        ret false;
    }

    Advance() {
        .index += 1;
        .column += 1;

        if .index >= .source.size() {
            .currentChar = '\0';
        } else {
            .currentChar = .source[.index];
        }

        if .IsNewline() {
            .column = 1;
            .line += 1;
        }
    }

    SkipWhitespace() {
        while .IsWhitespace() {
            .Advance();
        }
    }

    pub Parse() -> std::vector<Token> {
        mut tokens : std::vector<Token>;
        mut token : Token;
        while token.tokenType != TokenType::EndOfFile {
            token = .ParseToken();
            tokens.push_back(token);
        }
        ret tokens;
    }

    ParseToken() -> Token {
        while .IsNotNull() {
            if .IsWhitespace() {
                .SkipWhitespace();
                continue;
            }

            if .IsNewline() {
                .Advance();
                ret Token(TokenType::NewLine, "\n", .column, .line);
            }
            
            if .IsAlpha() || .IsChar('_') { ret .ParseIdentifier(); }

            if .IsDigit() { ret .ParseNumber(); }

            if .IsChar('"') { ret .ParseString(); }
            
            if .IsChar('\'') { ret .ParseChar(); }
            
            if .IsChar('/') {
                if .PeekEquals('/') {
                    .SkipComment();
                    continue;
                }
            }

            if .Switch3('.', '.', '.') { ret Token(TokenType::Ellipsis, "...", .column, .line); }
            if .Switch3('<', '<', '=') { ret Token(TokenType::LShiftAssign, "<<=", .column, .line); }
            if .Switch3('>', '>', '=') { ret Token(TokenType::RShiftAssign, ">>=", .column, .line); }

            if .Switch2('=', '=') { ret Token(TokenType::Equal, "==", .column, .line); }
            if .Switch2('!', '=') { ret Token(TokenType::NotEqual, "!=", .column, .line); }
            if .Switch2('<', '=') { ret Token(TokenType::LessEqual, "<=", .column, .line); }
            if .Switch2('>', '=') { ret Token(TokenType::GreaterEqual, ">=", .column, .line); }
            if .Switch2('+', '+') { ret Token(TokenType::Inc, "++", .column, .line); }
            if .Switch2('-', '-') { ret Token(TokenType::Dec, "--", .column, .line); }
            if .Switch2('&', '&') { ret Token(TokenType::And, "&&", .column, .line); }
            if .Switch2('|', '|') { ret Token(TokenType::Or, "||", .column, .line); }
            if .Switch2('+', '=') { ret Token(TokenType::AddAssign, "+=", .column, .line); }
            if .Switch2('-', '=') { ret Token(TokenType::SubAssign, "-=", .column, .line); }
            if .Switch2('*', '=') { ret Token(TokenType::MulAssign, "*=", .column, .line); }
            if .Switch2('/', '=') { ret Token(TokenType::DivAssign, "/=", .column, .line); }
            if .Switch2('%', '=') { ret Token(TokenType::ModAssign, "%=", .column, .line); }
            if .Switch2('&', '=') { ret Token(TokenType::AndAssign, "&=", .column, .line); }
            if .Switch2('|', '=') { ret Token(TokenType::OrAssign, "|=", .column, .line); }
            if .Switch2('^', '=') { ret Token(TokenType::XorAssign, "^=", .column, .line); }
            if .Switch2('>', '>') { ret Token(TokenType::RShift, ">>", .column, .line); }
            if .Switch2('<', '<') { ret Token(TokenType::LShift, "<<", .column, .line); }
            if .Switch2('-', '>') { ret Token(TokenType::Arrow, "->", .column, .line); }
            if .Switch2(':', ':') { ret Token(TokenType::ScopeResolution, "::", .column, .line); }

            if .Switch1('+') { ret Token(TokenType::Add, "+", .column, .line); }
            if .Switch1('-') { ret Token(TokenType::Sub, "-", .column, .line); }
            if .Switch1('*') { ret Token(TokenType::Mul, "*", .column, .line); }
            if .Switch1('/') { ret Token(TokenType::Div, "/", .column, .line); }
            if .Switch1('%') { ret Token(TokenType::Mod, "%", .column, .line); }
            if .Switch1('=') { ret Token(TokenType::Assign, "=", .column, .line); }
            if .Switch1('<') { ret Token(TokenType::Less, "<", .column, .line); }
            if .Switch1('>') { ret Token(TokenType::Greater, ">", .column, .line); }
            if .Switch1('!') { ret Token(TokenType::Not, "!", .column, .line); }
            if .Switch1('&') { ret Token(TokenType::And, "&", .column, .line); }
            if .Switch1('|') { ret Token(TokenType::Or, "|", .column, .line); }
            if .Switch1('^') { ret Token(TokenType::Xor, "^", .column, .line); }
            if .Switch1('~') { ret Token(TokenType::BitNot, "~", .column, .line); }
            if .Switch1('?') { ret Token(TokenType::Question, "?", .column, .line); }
            if .Switch1(':') { ret Token(TokenType::Colon, ":", .column, .line); }
            if .Switch1(';') { ret Token(TokenType::Semicolon, ";", .column, .line); }
            if .Switch1(',') { ret Token(TokenType::Comma, ",", .column, .line); }
            if .Switch1('.') { ret Token(TokenType::Dot, ".", .column, .line); }
            if .Switch1('(') { ret Token(TokenType::LParen, "(", .column, .line); }
            if .Switch1(')') { ret Token(TokenType::RParen, ")", .column, .line); }
            if .Switch1('[') { ret Token(TokenType::LBracket, "[", .column, .line); }
            if .Switch1(']') { ret Token(TokenType::RBracket, "]", .column, .line); }
            if .Switch1('{') { ret Token(TokenType::LBrace, "{", .column, .line); }
            if .Switch1('}') { ret Token(TokenType::RBrace, "}", .column, .line); }

            .Advance();
        }
        ret Token(TokenType::EndOfFile, "EOF", .column, .line);
    }

    ParseIdentifier() -> Token {
        mut identifier : std::string;
        while .IsAlphaNumeric() || .IsChar('_') {
            identifier += .currentChar;
            .Advance();
        }

        if identifier == "if" { ret Token(TokenType::If, "if", .column, .line); }
        if identifier == "elif" { ret Token(TokenType::Elif, "elif", .column, .line); }
        if identifier == "else" { ret Token(TokenType::Else, "else", .column, .line); }
        if identifier == "while" { ret Token(TokenType::While, "while", .column, .line); }
        if identifier == "for" { ret Token(TokenType::For, "for", .column, .line); }
        if identifier == "break" { ret Token(TokenType::Break, "break", .column, .line); }
        if identifier == "continue" { ret Token(TokenType::Continue, "continue", .column, .line); }
        if identifier == "ret" { ret Token(TokenType::Ret, "ret", .column, .line); }
        if identifier == "class" { ret Token(TokenType::Class, "class", .column, .line); }
        if identifier == "type" { ret Token(TokenType::Type, "type", .column, .line); }
        if identifier == "const" { ret Token(TokenType::Const, "const", .column, .line); }
        if identifier == "let" { ret Token(TokenType::Let, "let", .column, .line); }
        if identifier == "mut" { ret Token(TokenType::Mut, "mut", .column, .line); }
        if identifier == "import" { ret Token(TokenType::Import, "import", .column, .line); }
        if identifier == "include" { ret Token(TokenType::Include, "include", .column, .line); }
        if identifier == "pub" { ret Token(TokenType::Pub, "pub", .column, .line); }
        if identifier == "priv" { ret Token(TokenType::Priv, "priv", .column, .line); }
        if identifier == "static" { ret Token(TokenType::Static, "static", .column, .line); }
        if identifier == "virtual" { ret Token(TokenType::Virtual, "virtual", .column, .line); }
        if identifier == "new" { ret Token(TokenType::New, "new", .column, .line); }
        if identifier == "del" { ret Token(TokenType::Del, "del", .column, .line); }
        if identifier == "op" { ret Token(TokenType::Operator, "op", .column, .line); }
        if identifier == "enum" { ret Token(TokenType::Enum, "enum", .column, .line); }
        if identifier == "null" { ret Token(TokenType::Null, "null", .column, .line); }

        ret Token(TokenType::Ident, identifier, .column, .line);
    }

    ParseNumber() -> Token {
        mut number : std::string;
        while .IsDigit() {
            number += .currentChar;
            .Advance();
        }
        if .currentChar == '.' {
            number += .currentChar;
            .Advance();
            while .IsDigit() {
                number += .currentChar;
                .Advance();
            }
            ret Token(TokenType::Float, number, .column, .line);
        }
        ret Token(TokenType::Int, number, .column, .line);
    }

    ParseString() -> Token {
        .Advance();
        mut string : std::string;
        while !.IsChar('"') {
            string += .currentChar;

            if .IsChar(92) { // '\'
                .Advance();
                string += .currentChar;
            }

            .Advance();
        }
        .Advance();
        ret Token(TokenType::String, string, .column, .line);
    }

    // TODO: accept scape sequences
    ParseChar() -> Token {
        .Advance();
        mut character : std::string;
        while !.IsChar(39) && .IsNotNull() {
            character += .currentChar;
            
            if .IsChar(92) { // '\'
                .Advance();
                character += .currentChar;
            }

            .Advance();
        }
        .Advance();
        ret Token(TokenType::Char, character, .column, .line);
    }

    SkipComment() -> void {
        mut isNotNewline : bool = true;
        mut isNotNull : bool = true;
        while isNotNull && isNotNewline {
            .Advance();
            isNotNull = .IsNotNull();
            isNotNewline = !.IsNewline();
        }
    }

    Switch1(c : char) -> bool {
        if .IsChar(c) {
            .Advance();
            ret true;
        }
        ret false;
    }

    Switch2(expected1 : char, expected2 : char) -> bool {
        if .currentChar == expected1 && .PeekEquals(expected2) {
            .Advance();
            .Advance();
            ret true;
        }
        ret false;
    }

    Switch3(expected1 : char, expected2 : char, expected3 : char) -> bool {
        if .currentChar == expected1 && .PeekEquals(expected2) && .PeekEquals(expected3) {
            .Advance();
            .Advance();
            .Advance();
            ret true;
        }
        ret false;
    }

    // Character utilities
    IsChar(c : char) -> bool {
        ret .currentChar == c;
    }

    IsNull() -> bool {
        ret .currentChar == '\0';
    }

    IsNotNull() -> bool {
        ret !.IsNull();
    }

    IsWhitespace() -> bool {
        ret .currentChar == ' ' || .currentChar == '\t';
    }

    IsAlpha() -> bool {
        ret .currentChar >= 'a' && .currentChar <= 'z' || .currentChar >= 'A' && .currentChar <= 'Z';
    }

    IsDigit() -> bool {
        ret .currentChar >= '0' && .currentChar <= '9';
    }

    IsAlphaNumeric() -> bool {
        ret .IsAlpha() || .IsDigit();
    }

    IsNewline() -> bool {
        ret .currentChar == '\n';
    }
}